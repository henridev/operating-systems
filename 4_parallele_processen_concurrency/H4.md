# 

[TOC]

# Concurrency

## 1. inleiding

*run several programs or several parts of a program in parallel.*

we zagen hoe op de meeste moderne computersystemen meerdere processen gelijktijdig actief kunnen zijn. Deze
processen kunnen soms gelijktijdig uitgevoerd worden. 

- Multiprogrammering: het beheer van meerdere processen in een systeem met 1 processor
- Multiprocessing: het beheer van meerdere processen in een systeem met meerdere processoren
- Gedistribueerde verwerking: het beheer van meerdere processen die worden uitgevoerd op een aantal verspreide (= gedistribueerde) computersystemen

<img src="https://res.cloudinary.com/dri8yyakb/image/upload/v1615880012/Screenshot_from_2021-03-16_08-33-09_vesw8f.png"/>



**Concurrency / parallelle processen**  

- bij computerprocessen een belangrijke. Doordat enorme rekencapaciteit in een kleine chip paste, zijn multiprocessors (= een computersysteem met twee of meer processoren)  populair met deze cpu's kunnen meerdere taken gelijktijdig worden uitgevoert => + productiviteit
- enkele uitdagingen:
  - Hoe kunnen verschillende processen met elkaar communiceren?
  - Wat moet het OS doen wanneer processen computerbronnen delen, of conflicten hebben bij bronnen?
  - Hoe kunnen activiteiten binnen verschillende processen gesynchroniseerd worden?
  - Hoe moet de beschikbare processortijd verdeeld worden over de verschillende processen?
- het tegengestelde van concurrency zijn **sequentiele processen**, waarbij alle stappen strikt na elkaar worden uitgevoerd.

Concurrency in verschillende situaties: (niet beperkt tot computersystemen met +1 processoren => met 1 CPU kan concurrency optreden)

- Meerdere toepassingen: bij multiprogrammering kunnen er verschillende processen gelijktijdig actief zijn, en multiprogrammering werd uitgevonden om de verwerkingstijd (processortijd) dynamisch te kunnen verdelen over een aantal actieve toepassingen
- Gestructureerde toepassingen: als uitbreiding op de beginselen van modulair ontwerpen en gestructureerd programmeren kunnen sommige toepassingen effectief worden geprogrammeerd als een verzameling van gelijktijdige processen
- Structuur van besturingssysteem: dezelfde voordelen van het structureren gelden ook voor de systeemprogrammeur, en besturingssystemen zelf worden vaak geïmplementeerd als een verzameling processen

> concurrent = gelijktijdig (al dan niet schijnbaar)
>
> parallel = tegelijk (op zelfde moment)
>
> parallelisme = parallel
>
> <img src="https://www.codeproject.com/KB/cs/1267757/8e925d68-4f47-4ef9-8d51-6a39f19c75d2.Jpeg"/>

<img src="https://res.cloudinary.com/dri8yyakb/image/upload/v1615883959/Untitled_Diagram-Page-5_2_eugkpo.png"/>

### multiprogrammering => concurrency 1 cpu

Concurrency = toepassing gaan vooruit op meer dan één taak - **(schijnbaar)** **tegelijkertijd** 

Als de computer slechts één CPU heeft, kan de toepassing op exact hetzelfde moment geen vooruitgang boeken, maar is er meer dan één taak aan de gang op een moment binnen de toepassing. Om tegelijkertijd vooruitgang te boeken met meer dan één taak **schakelt de CPU tussen de verschillende taken tijdens de uitvoering**.

### multiprocessing (concurrency +1 cpu) => parallel (concurrent) execution 

**parallel execution** =  **parallele** uitvoering van taken, tegelijkertijd vooruitgang boekt op meer dan één taak. 

**parallel concurrent execution / parallelle gelijktijdig uitvoering** = verschillende taken verdeeld over meerdere CPU’s. Taken die op dezelfde CPU worden uitgevoerd, worden **gelijktijdig** (in afwisseling) uitgevoerd, terwijl taken die op verschillende CPU's worden uitgevoerd parallel worden uitgevoerd.

### parallelisme

een toepassing splits zijn werk op in kleinere subtaken die parallel kunnen worden verwerkt (bvb. op +1 CPU's op exact hetzelfde moment)

**Parallellisme verwijst *niet* naar hetzelfde uitvoeringsmodel als parallelle gelijktijdige uitvoering** 

Om echte parallellisme te bereiken moet een toepassing meer dan 1 subtaak hebben die wordt uitgevoerd - en elke subtaak moet op afzonderlijke CPU's / CPU-cores / GPU-cores draaien

betekent dat delen van deze toepassing gelijktijdig worden uitgevoerd (op dezelfde CPU) en delen parallel worden uitgevoerd (op verschillende CPU’s)



## 2. mutual exclusion

<img src="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/java-intrinsic-locks/images/lock.png"/>



- **Wederzijdse uitsluiting** = eis dat wanneer een proces in een kritieke sectie zit er geen andere proces kan zijn die ook in een kritieke sectie zitten waarbij dezelfde gedeelde bronnen worden gebruikt. 
- regelen van de toegang tot gedeelde bronnen is een belangrijk probleem in de computerwetenschappen. omdat taken willekeurig kunnen starten of stoppen.
- Soms meerdere taken of processen spreken tegelijk dezelfde gedeelde computerbronnen (bv. wnr hetzelfde deel van het gedeeld RAM willen aanspreken.) =>  kan voor conflicten en inconsistenties zorgen. 
- een procesbestaat  uit meerdere instructies die uitgevoerd worden op een processor (zie vorige hfst). 

- **kritieke sectie** = De instructies (code) voor het aanspreken van die gedeelde bronnen (bijvoorbeeld lezen of schrijven naar gemeenschappelijke data) noemen we een. 
  - belangrijk dat er op elk moment max 1 proces in een kritieke sectie zit.
  - We willen processen gelijktijdig laten uitvoeren, en tegelijkertijd voorkomen dat delen van die processen (kritieke secties) parallel worden verwerkt.
  - Wanneer parallelle processen zich toegang verschaffen tot het gemeenschappelijke geheugen, bevatten hun kritieke secties de opdrachten die deze resources aanspreken. 
  - kritieke sectie = de code die naar gemeenschappelijke data verwijst. Als de uitvoering van een proces in de kritieke
    sectie is aangeland, moeten wij er voor zorgen dat elk ander proces zijn eigen kritieke
    sectie niet betreedt. Omgekeerd moeten wij ook opletten dat een proces zijn kritieke
    13
    sectie niet binnenkomt op het moment dat een ander proces in zijn kritieke sectie zit.


### voorbeeld. 

Stel in het geheugen een globale variabele const getal.  Een proces kan deze waarde aanpassen via volgende 3
instructies:

1. Lees de huidige waarde van de variabele getal in vanuit het geheugen
2. Verhoog deze waarde met 1
3. Schrijf de nieuwe waarde voor getal weg naar het geheugen

Stel dat er 2 processen zijn A/B, die **parallel** uitgevoerd worden, en beide willen bovenstaande instructies uitvoeren. stel instructies A1, A2, A3 (instructies 1, 2 en 3 voor proces A) en B1, B2, B3 (voor proces B). 

- Als beide processen na elkaar de instructies uitvoeren is er geen probleem, en zal de waarde van getal met 2 verhoogd zijn. De volgorde van uitvoering is dan bijvoorbeeld: A1 – A2 – A3 – B1 – B2 – B3
- een proces kan echter onderbreken tijdens de uitvoering (zie hfst3). Stel bijvoorbeeld dat proces A onderbroken wordt na
  uitvoeren van de eerste instructie, en proces B van aan bod komt. De volgorde van uitvoeren is dan bijvoorbeeld: A1 – B1 – B2 – B3 – A2 – A3 Merk op dat de eerste instructie hier niet opnieuw uitgevoerd wordt, waardoor proces A nog de ‘oude’ waarde kent van de variabele getal. Na uitvoeren van alle stappen zal getal hier dus niet verhoogd zijn met 2, maar met 1.
  Om dit te voorkomen, **zullen we de 3 instructies dus moeten groeperen in een kritieke sectie, en afdwingen dat proces B deze instructies niet mag uitvoeren wanneer proces A hier reeds mee begonnen is.**

### wederzijdse uitsluiting bij multi-processing

<img src="https://res.cloudinary.com/dri8yyakb/image/upload/v1615887209/Screenshot_from_2021-03-16_10-32-15_r8ja3a.png"/>

- verschillende niveaus van concurrency. Niet alleen processen, maar ook activiteiten binnen één proces kunnen parallel worden uitgevoerd (**parallelisme**). 
- In dit hoofdstuk zullen we hoofdzakelijk processen bespreken, maar de principes gelden eveneens voor activiteiten binnen één proces. 
- Als parallelle processen niets gemeenschappelijk gebruiken, is er geen probleem. De moeilijkheden ontstaan wanneer de processen het gemeenschappelijke geheugen aanspreken. => **krtiieke secties**

### wederzijdse uitsluiting bij multi-programmering

Ook wanneer een computersysteem maar één processor heeft, zijn gelijklopende (concurrent) processen mogelijk. De processen kunnen in dergelijk geval uiteraard niet parallel (gelijktijdig) uitgevoerd worden, maar ze kunnen wel op hetzelfde moment proberen de besturing van de CPU te krijgen. Wanneer twee van zulke processen het gemeenschappelijk geheugen willen aanspreken, kunnen er nog steeds problemen ontstaan, en kan wederzijds uitsluiting nodig zijn.

### praktijk

- niet eenvoudig om wederzijdse uitsluiting af te dwingen.
- Een eenvoudige oplossing zou kunnen zijn om met 1 globale variabele (bijvoorbeeld een boolean) bij te houden of er een proces in een kritieke sectie zit, maar dan is het probleem verschoven naar de toegang tot deze globale variabele.
- Er bestaan algoritmes die een oplossing bieden voor het probleem van wederzijdse uitsluiting. Het algoritme van Dekker bijvoorbeeld is de eerste bekende juiste oplossing voor dit probleem, maar is beperkt tot wederzijdse uitsluiting voor 2
  parallelle processen. 
- In 1981 werd er een oplossing geformuleerd, Peterson’s algoritme, die ook bruikbaar is voor wederzijdse uitsluiting bij meer dan 2 processen. De details van deze algoritmes vallen echter buiten de scope van deze cursus.
- Daarnaast bestaat er ook een alternatieve oplossing, die gebruik maakt van **semaforen**. Een semafoor is een soort van integer variabele, bedacht door Dijkstra, die slecht door enkele primitieve operaties kan gewijzigd worden. Een **primitieve**
  **operatie** is een operatie die niet onderbroken kan worden: ofwel wordt de operatie volledig uitgevoerd, ofwel wordt deze volledig ongedaan gemaakt.
- Een ander alternatief is om monitoren te gebruiken. Een monitor is een constructie in een programmeertaal die een functionaliteit biedt die vergelijkbaar is met die van semaforen, maar gemakkelijker te besturen is.



```c
// decker alg voorbeeld

flag[0] = false; // p0 in critical section
flag[1] = false; // p1 in critical section
turn = 0;

// P0
flag[0] = true;
while(flag[1]){
    flag[0] = flase;
    while(turn != 0){
        // busy wait
    }
    flag[0] = true;
}
// critical section
turn = 1;
flag[0] = false;

// P1
flag[1] = true;
while(flag[0]){
    flag[1] = flase;
    while(turn != 1){
        // busy wait
    }
    flag[1] = true;
}
// critical section
turn = 0;
flag[1] = false;
```

<img src="https://slideplayer.com/slide/15365498/93/images/29/Semaphores+Semaphores+are+a+kind+of+generalized+locks.jpg" style="zoom:50%;" />

### mutual exclussion buiten gedeeld geheugen

In de vorige slides hebben we wederzijdse uitsluiting besproken in de context van hetregelen van de toegang van verschillende processen die uitgevoerd worden op de CPU naar gemeenschappelijk geheugen. Er bestaan echter ook andere vormen van
wederzijdse uitsluiting:

- de toegang naar bestanden te regelen, en bijvoorbeeld te voorkomen dat 2 processen gelijktijdig naar hetzelfde bestand willen schrijven (en zo elkaars wijzigingen ondermijnen).
- de toegang tot bepaalde hardware bronnen te regelen. Stel bijvoorbeeld dat 2 processen op exact hetzelfde
moment een taak willen versturen naar een printer... Gelukkig gaat het besturingssysteem dit niet toelaten, en de printertaken bijhouden in een wachtrij zodat de documenten één voor één (sequentieel) afgeprint worden.

Algemeen kunnen we stellen dat het de taak is van het besturingssysteem om (waar nodig) wederzijdse uitsluiting te garanderen tot gedeelde computerbronnen.



## 3. synchronisatie



*het proces of het resultaat van iets gelijktijdig maken.* 

Binnen de context van concurrency kunnen we synchronisatie ook definiëren als het **opleggen van een dwingende volgorde aan events die door concurrente, asynchrone processen worden uitgevoerd.** Bij concurrente processen weten we niet welk proces wanneer aan bod komt, maar toch willen we garanderen dat de uitvoering van (delen van) bepaalde processen in een bepaalde volgorde verlopen



```java
public class WithoutSync {
    private static final int NUM_EXECUTIONS = 100000000;

    private static void someLongOperation() { /* NO-OP */ }

    public static void main(String[] args) {
        final long[] numElements = {0};

        Thread incrementThread = new Thread() {
            @Override
            public void run() {
                for (long count = 0; count < NUM_EXECUTIONS; count++) {
                    someLongOperation();
                    numElements[0] += 1;
                }
            }
        };

        Thread decrementThread = new Thread() {
            @Override
            public void run() {
                for (long count = 0; count < NUM_EXECUTIONS; count++) {
                    someLongOperation();
                    numElements[0] -= 1;
                }
            }
        };

        // Start the threads
        incrementThread.start(); decrementThread.start();

        // Wait for jobs to finish
        try { incrementThread.join(); decrementThread.join(); } 
        catch (InterruptedException e) { /* NO-OP */ }

        // Print the result
        System.out.println("Result is: " + numElements[0]);
    }
}

public class WithSync {
    private static final int NUM_EXECUTIONS = 100000000;
    
    // This Object ensures synchronization
    private static final Object mutexLock = new Object();

    private static void someLongOperation() { /* NO-OP */ }

    public static void main(String[] args) {
        final long[] numElements = {0};
        Thread incrementThread = new Thread() {
            @Override
            public void run() {
                for (long count = 0; count < NUM_EXECUTIONS; count++) {
                    someLongOperation();
                    synchronized(mutexLock) {
                        numElements[0] += 1;
                    }
                }
            }
        };

        Thread decrementThread = new Thread() {
            @Override
            public void run() {
                for (long count = 0; count < NUM_EXECUTIONS; count++) {
                    someLongOperation();
                    synchronized(mutexLock) {
                        numElements[0] -= 1;
                    }
                }
            }
        };

        // Start the threads
        incrementThread.start(); decrementThread.start();

        // Wait for jobs to finish
        try { incrementThread.join(); decrementThread.join(); }
        catch (InterruptedException e) { /* NO-OP */ }

        // Print the result
        System.out.println("Result is: " + numElements[0]);
    }
}
```





















## 4. deadlocks



































## 5. threads





































